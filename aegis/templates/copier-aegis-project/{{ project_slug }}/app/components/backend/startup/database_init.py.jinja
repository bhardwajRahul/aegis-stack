"""
Database initialization startup hook.

Runs Alembic migrations and {% if database_engine == "sqlite" %}ensures directory structure exists{% else %}verifies connectivity{% endif %}
when the backend starts up (only when database component is included).
"""
{% if include_database %}

{% if database_engine == "sqlite" %}
from pathlib import Path
{% endif %}
from app.core.log import logger

{% if include_auth %}
# Import models to register them with SQLModel metadata
from app.models.user import User  # noqa: F401
{% endif %}


def _run_migrations() -> bool:
    """
    Run Alembic migrations programmatically.

    Returns:
        True if migrations ran successfully, False otherwise.
    """
    try:
        from alembic.config import Config
        from alembic import command

        alembic_cfg = Config("alembic/alembic.ini")
        command.upgrade(alembic_cfg, "head")
        logger.info("Database migrations applied successfully")
        return True
    except Exception as e:
        logger.error(f"Failed to run migrations: {e}")
        return False


async def startup_database_init() -> None:
    """
    Initialize database and run migrations.

    This hook runs when the backend starts to:
    1. {% if database_engine == "sqlite" %}Ensure database directory exists{% else %}Verify database connectivity{% endif %}
    2. Run Alembic migrations (idempotent - safe to run multiple times)
    3. Verify database schema is ready
    {% if include_ai and database_engine == "postgres" %}4. Sync LLM catalog (postgres only - SQLite syncs during generation){% endif %}
    """
    try:
{% if database_engine == "sqlite" %}
        # Ensure database directory exists
        from app.core.db import DATABASE_PATH
        db_path = Path(DATABASE_PATH)
        db_path.parent.mkdir(parents=True, exist_ok=True)
{% endif %}

        # Run Alembic migrations (idempotent)
        migrations_ok = _run_migrations()

        if not migrations_ok:
            logger.warning("Migrations failed - database may not be fully initialized")
            # Continue anyway to allow debugging

        # Verify database connectivity
        try:
            from app.core.db import db_session
            from sqlmodel import text
            from sqlalchemy import inspect

            with db_session(autocommit=False) as session:
                # Basic connectivity check
                session.exec(text("SELECT 1"))

                # Verify alembic_version table exists
                inspector = inspect(session.connection())
                table_names = inspector.get_table_names()

                if "alembic_version" in table_names:
                    logger.info(f"Database ready with {len(table_names)} tables")
                else:
                    logger.warning("alembic_version table missing after migrations")

        except Exception as e:
            logger.warning(f"Database verification failed: {e}")
            # Don't fail startup - let the app run and show clear errors

{% if include_ai and database_engine == "postgres" %}
        # Sync LLM catalog (postgres only - SQLite syncs during generation)
        # Uses sync Session because sync_llm_catalog does sync DB ops (async is for HTTP calls)
        try:
            logger.info("Starting LLM catalog sync...")
            from sqlmodel import Session
            from app.core.db import engine
            from app.services.ai.etl import sync_llm_catalog

            logger.info("Creating database session for LLM sync...")
            with Session(engine) as session:
                logger.info("Calling sync_llm_catalog...")
                result = await sync_llm_catalog(session, mode="chat")
                logger.info(f"LLM catalog synced: {result.total_synced} models")
        except Exception as e:
            logger.warning(f"LLM catalog sync skipped: {e}")
{% endif %}

    except Exception as e:
        logger.error(f"Database initialization failed: {e}")
        raise


# Export the startup hook function
startup_hook = startup_database_init
{% endif %}